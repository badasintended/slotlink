import com.matthewprenger.cursegradle.CurseArtifact
import com.matthewprenger.cursegradle.CurseProject
import com.matthewprenger.cursegradle.CurseRelation
import com.modrinth.minotaur.dependencies.DependencyType
import com.modrinth.minotaur.dependencies.ModDependency
import groovy.json.JsonGenerator
import groovy.json.JsonSlurper
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
    kotlin("jvm").version("1.8.0")
    kotlin("plugin.serialization").version("1.8.0")

    id("fabric-loom").version("1.1.+")
    id("com.matthewprenger.cursegradle").version("1.4.0")
    id("com.modrinth.minotaur").version("2.4.5")
    id("maven-publish")
}

val prop = Property()
val env: Map<String, String> = System.getenv()

version = env["MOD_VERSION"] ?: "local"

repositories {
    maven("https://maven.bai.lol")
    maven("https://maven.shedaniel.me/")
}

dependencies {
    minecraft("com.mojang:minecraft:${prop["minecraft"]}")
    mappings("net.fabricmc:yarn:${prop["yarn"]}:v2")

    modImplementation("net.fabricmc:fabric-loader:${prop["fabricLoader"]}")

    modImplementation("net.fabricmc.fabric-api:fabric-api:${prop["fabricApi"]}")
    modImplementation("net.fabricmc:fabric-language-kotlin:${prop["fabricKotlin"]}")

    modCompileOnly("me.shedaniel:RoughlyEnoughItems-api-fabric:${prop["rei"]}")
    modCompileOnly("me.shedaniel:RoughlyEnoughItems-default-plugin-fabric:${prop["rei"]}")
    modRuntimeOnly("me.shedaniel:RoughlyEnoughItems-fabric:${prop["rei"]}")
    modRuntimeOnly("dev.architectury:architectury-fabric:${prop["architectury"]}")

    modCompileOnly("mcp.mobius.waila:wthit-api:fabric-${prop["wthit"]}")
    modRuntimeOnly("mcp.mobius.waila:wthit:fabric-${prop["wthit"]}")
    modRuntimeOnly("lol.bai:badpackets:fabric-${prop["badpackets"]}")
}

sourceSets {
    val main by getting

    val devrun by creating
    val datagen by creating

    listOf(devrun, datagen).forEach {
        it.compileClasspath += main.compileClasspath + main.output
        it.runtimeClasspath += main.runtimeClasspath + main.output
    }

    val generated by creating {
        compiledBy("runDatagen")
        resources {
            srcDir(file("src/generated/output"))
        }
    }

    devrun.apply {
        compileClasspath += generated.output
        runtimeClasspath += generated.output
    }
}

loom {
    runs {
        getByName("client") {
            source("devrun")
        }

        getByName("server") {
            source("devrun")
        }

        create("datagen") {
            server()
            name("Data Generation")
            vmArgs(
                "-Dfabric-api.datagen",
                "-Dfabric-api.datagen.output-dir=${file("src/generated/output")}",
                "-Dfabric-api.datagen.modid=slotlink_datagen"
            )
            runDir("build/datagen")
            source("datagen")
        }
    }
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

tasks.getByName("runDatagen") {
    inputs.dir(file("src/datagen"))
    outputs.dir(file("src/generated"))
}

tasks.withType<JavaCompile> {
    options.encoding = "UTF-8"
}

tasks.withType<KotlinCompile> {
    kotlinOptions {
        jvmTarget = "17"
    }
}

tasks.jar {
    from(sourceSets["generated"].output) {
        exclude("fabric.mod.json")
        exclude(".cache/**")
    }
}

tasks.getByName("processGeneratedResources") {
    dependsOn("runDatagen")
}

tasks.withType<ProcessResources> {
    inputs.property("version", project.version)

    filesMatching("fabric.mod.json") {
        expand("version" to project.version)
    }

    doLast {
        val slurper = JsonSlurper()
        val json = JsonGenerator.Options()
            .disableUnicodeEscaping()
            .build()
        fileTree(outputs.files.asPath) {
            include("**/*.json")
            forEach {
                val mini = json.toJson(slurper.parse(it, "UTF-8"))
                it.writeText(mini)
            }
        }
    }
}

curseforge {
    env["CURSEFORGE_API"]?.let { CURSEFORGE_API ->
        apiKey = CURSEFORGE_API
        project(closureOf<CurseProject> {
            id = prop["cf.projectId"]
            releaseType = prop["cf.releaseType"]

            changelogType = "markdown"
            changelog = "https://github.com/badasintended/slotlink/releases/tag/${project.version}"

            mainArtifact(tasks["remapJar"], closureOf<CurseArtifact> {
                displayName = "[${prop["minecraft"]}] v${project.version}"
            })

            addGameVersion("Fabric")
            prop["cf.gameVersion"].split(", ").forEach {
                addGameVersion(it)
            }

            relations(closureOf<CurseRelation> {
                prop["cf.require"].split(", ").forEach {
                    requiredDependency(it)
                }
                prop["cf.optional"].split(", ").forEach {
                    optionalDependency(it)
                }
            })

            afterEvaluate {
                uploadTask.dependsOn("build")
            }
        })
    }
}

modrinth {
    env["MODRINTH_TOKEN"]?.let { MODRINTH_TOKEN ->
        token.set(MODRINTH_TOKEN)

        projectId.set(prop["mr.projectId"])
        versionNumber.set(version.toString())
        versionType.set(prop["mr.releaseType"])
        changelog.set("https://github.com/badasintended/slotlink/releases/tag/${project.version}")

        uploadFile.set(tasks["remapJar"])
        loaders.addAll("fabric", "quilt")
        gameVersions.addAll(prop["mr.gameVersion"].split(", "))

        prop["mr.require"].split(", ").forEach {
            dependencies.add(ModDependency(it, DependencyType.REQUIRED))
        }

        prop["mr.optional"].split(", ").forEach {
            dependencies.add(ModDependency(it, DependencyType.OPTIONAL))
        }
    }
}

class Property {

    operator fun get(name: String) = project.property(name).toString()

}
